#!/bin/bash
# -----------------------------------------------------------------------------
# PROJECT   : Pubpak
# COPYRIGHT : Andy Thomas (C) 2022-23
# LICENSE   : GPL-3.0-or-later
# HOMEPAGE  : https://github.com/kuiperzone/Pubpak
#
# Pubpak is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# Pubpak is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with Pubpak. If not, see <https://www.gnu.org/licenses/>.
# -----------------------------------------------------------------------------

###############################
# CONSTANTS
###############################

declare -r _SCRIPT_VERSION="2.0.0"
declare -r _SCRIPT_TITLE="PUBPAK for .NET"
declare -r _SCRIPT_IMPL_MIN=1
declare -r _SCRIPT_IMPL_MAX=2
declare -r _SCRIPT_COPYRIGHT="Copyright 2023 Andy Thomas"
declare -r _SCRIPT_WEBSITE="https://github.com/kuiperzone/Pubpak"

declare -r _SCRIPT_NAME="pubpak"
declare -r _DEFAULT_CONF="${_SCRIPT_NAME}.conf"

declare -r _APPIMAGE_KIND="appimage"
declare -r _FLATPAK_KIND="flatpak"
declare -r _ZIP_KIND="zip"
declare -r _DOTNET_NONE="null"
declare -r _HOST_ARCH=$(uname -m)


###############################
# FUNCTIONS
###############################

function assert_result
{
    local _ret=$?

    if [ ${_ret} -ne 0 ]; then
        echo
        exit ${_ret}
    fi
}

function exec_or_die
{
    echo "${1}"
    eval "${1}"
    assert_result
}

function ensure_directory
{
    local _path="${1}"

    if [ ! -d "${_path}" ]; then
        mkdir -p "${_path}"
        assert_result
    fi
}

function remove_path
{
    local _path="${1}"

    if [ -d "${_path}" ]; then
        rm -rf "${_path}"
        assert_result
    elif [ -f "${_path}" ]; then
        rm -f "${_path}"
        assert_result
    fi
}

function assert_mandatory
{
    local _name="${1}"
    local _value="${2}"

    if [ "${_value}" == "" ]; then
        echo "${_name} undefined in: ${_conf_arg_value}"
        echo
        exit 1
    fi
}

function assert_flag
{
    local _name="${1}"
    local _value="${2}"

    if [ "${_value}" != "true" ] && [ "${_value}" != "false" ]; then
        echo "Invalid ${_name} value: ${_value}"
        echo "Must be true of false only"
        echo
        exit 1
    fi
}

function assert_opt_file
{
    local _name="${1}"
    local _value="${2}"

    if [ "${_value}" != "" ] && [ ! -f "${_value}" ]; then
        echo "File not found: ${_value}"

        if [ "${_name}" != "" ]; then
            echo "See ${_name} in: ${_conf_arg_value}"
        fi

        echo
        exit 1
    fi
}

###############################
# HANDLE ARGUMENTS
###############################

# Specify conf file
declare -r _CONF_ARG="f"
declare -r _CONF_ARG_NAME="conf"
_conf_arg_value="${_DEFAULT_CONF}"
_arg_syntax=":${_CONF_ARG}:"

# Runtime ID
declare -r _RID_ARG="r"
declare -r _RID_ARG_NAME="runtime"
_rid_arg_value=""
_arg_syntax="${_arg_syntax}${_RID_ARG}:"

# Package kind
declare -r _KIND_ARG="k"
declare -r _KIND_ARG_NAME="kind"
declare -l _kind_arg_value="${_APPIMAGE_KIND}"
_arg_syntax="${_arg_syntax}${_KIND_ARG}:"

# Application version
declare -r _APPVERSION_ARG="x"
declare -r _APPVERSION_ARG_NAME="app-version"
_appversion_arg_value=""
_arg_syntax="${_arg_syntax}${_APPVERSION_ARG}:"

# Dotnet property, i.e. /p:DefineConstants=TRACE
declare -r _PROPERTY_ARG="p"
declare -r _PROPERTY_ARG_NAME="property"
_property_arg_value=""
_arg_syntax="${_arg_syntax}${_PROPERTY_ARG}:"

# Arch override
declare -r _ARCH_ARG="a"
declare -r _ARCH_ARG_NAME="arch"
_arch_arg_value=""
_arg_syntax="${_arg_syntax}${_ARCH_ARG}:"

# Output name
declare -r _OUTPUT_ARG="o"
declare -r _OUTPUT_ARG_NAME="output"
_output_arg_value=""
_arg_syntax="${_arg_syntax}${_OUTPUT_ARG}:"

# Run app
declare -r _RUNAPP_ARG="u"
declare -r _RUNAPP_ARG_NAME="run"
_runapp_arg_value=false
_arg_syntax="${_arg_syntax}${_RUNAPP_ARG}"

# Verbose
declare -r _VERBOSE_ARG="b"
declare -r _VERBOSE_ARG_NAME="verbose"
_verbose_arg_value=false
_arg_syntax="${_arg_syntax}${_VERBOSE_ARG}"

# Skip yes (no prompt)
declare -r _SKIPYES_ARG="y"
declare -r _SKIPYES_ARG_NAME="skip-yes"
_skipyes_arg_value=false
_arg_syntax="${_arg_syntax}${_SKIPYES_ARG}"

# Show version
declare -r _VERSION_ARG="v"
declare -r _VERSION_ARG_NAME="version"
_version_arg_value=false
_arg_syntax="${_arg_syntax}${_VERSION_ARG}"

# Show help
declare -r _HELP_ARG="h"
declare -r _HELP_ARG_NAME="help"
_help_arg_value=false
_arg_syntax="${_arg_syntax}${_HELP_ARG}"

_exit_help=0

# Transform long options to short ones
for arg in "${@}"; do
  shift
  case "${arg}" in
    ("--${_CONF_ARG_NAME}") set -- "$@" "-${_CONF_ARG}" ;;
    ("--${_RID_ARG_NAME}") set -- "$@" "-${_RID_ARG}" ;;
    ("--${_KIND_ARG_NAME}") set -- "$@" "-${_KIND_ARG}" ;;
    ("--${_APPVERSION_ARG_NAME}") set -- "$@" "-${_APPVERSION_ARG}" ;;
    ("--${_PROPERTY_ARG_NAME}") set -- "$@" "-${_PROPERTY_ARG}" ;;
    ("--${_ARCH_ARG_NAME}") set -- "$@" "-${_ARCH_ARG}" ;;
    ("--${_OUTPUT_ARG_NAME}") set -- "$@" "-${_OUTPUT_ARG}" ;;
    ("--${_RUNAPP_NAME}") set -- "$@" "-${_RUNAPP_ARG}" ;;
    ("--${_VERBOSE_ARG_NAME}") set -- "$@" "-${_VERBOSE_ARG}" ;;
    ("--${_SKIPYES_ARG_NAME}") set -- "$@" "-${_SKIPYES_ARG}" ;;
    ("--${_VERSION_ARG_NAME}") set -- "$@" "-${_VERSION_ARG}" ;;
    ("--${_HELP_ARG_NAME}") set -- "$@" "-${_HELP_ARG}" ;;
    ("--"*)
        echo "Illegal argument: ${arg}"
        echo

        _exit_help=1
        break
        ;;
    (*) set -- "$@" "${arg}" ;;
  esac
done

if [ ${_exit_help} == 0 ]; then
    # Read arguments
    while getopts ${_arg_syntax} arg; do
        case "${arg}" in
            (${_CONF_ARG}) _conf_arg_value="${OPTARG}" ;;
            (${_RID_ARG}) _rid_arg_value="${OPTARG}" ;;
            (${_KIND_ARG}) _kind_arg_value="${OPTARG}" ;;
            (${_APPVERSION_ARG}) _appversion_arg_value="${OPTARG}" ;;
            (${_PROPERTY_ARG}) _property_arg_value="${_property_arg_value} -p:${OPTARG}" ;;
            (${_ARCH_ARG}) _arch_arg_value="${OPTARG}" ;;
            (${_OUTPUT_ARG}) _output_arg_value="${OPTARG}" ;;
            (${_RUNAPP_ARG}) _runapp_arg_value=true ;;
            (${_VERBOSE_ARG}) _verbose_arg_value=true ;;
            (${_SKIPYES_ARG}) _skipyes_arg_value=true ;;
            (${_VERSION_ARG}) _version_arg_value=true ;;
            (${_HELP_ARG}) _help_arg_value=true ;;
            (*)
                echo "Illegal argument"
                echo

                _exit_help=1
                break
                ;;
        esac
    done
fi

# Handle and help and version
if [ ${_version_arg_value} == true ]; then
    echo "${_SCRIPT_TITLE} ${_SCRIPT_VERSION}"
    echo "${_SCRIPT_COPYRIGHT}"
    echo "${_SCRIPT_WEBSITE}"
    echo
    echo "${_SCRIPT_TITLE} is free software: you can redistribute it and/or modify it under"
    echo "the terms of the GNU General Public License as published by the Free Software"
    echo "Foundation, either version 3 of the License, or (at your option) any later version."
    echo
    echo "${_SCRIPT_TITLE} is distributed in the hope that it will be useful, but WITHOUT"
    echo "ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS"
    echo "FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details."
    echo

    exit 0
fi

if [ ${_help_arg_value} == true ] || [ $_exit_help != 0 ]; then

    _indent="  "
    echo "Usage:"
    echo "${_indent}${_SCRIPT_NAME} [-flags] [-option-n value-n]"
    echo

    echo "Help Options:"
    echo "${_indent}-${_HELP_ARG}, --${_HELP_ARG_NAME}"
    echo "${_indent}Show help information flag."
    echo
    echo "${_indent}-${_VERSION_ARG}, --${_VERSION_ARG_NAME}"
    echo "${_indent}Show version and about information flag."
    echo

    echo "Build Options:"
    echo "${_indent}-${_CONF_ARG}, --${_CONF_ARG_NAME} value"
    echo "${_indent}Specifies the conf file. Defaults to ${_SCRIPT_NAME}.conf."
    echo
    echo "${_indent}-${_KIND_ARG}, --${_KIND_ARG_NAME} value"
    echo "${_indent}Package output kind. Value must be one of: '${_APPIMAGE_KIND}', '${_FLATPAK_KIND}' or '${_ZIP_KIND}'."
    echo "${_indent}Default is '${_APPIMAGE_KIND}' if unspecified."
    echo
    echo "${_indent}-${_RID_ARG}, --${_RID_ARG_NAME} value"
    echo "${_indent}Dotnet publish runtime identifier. Valid examples include: 'linux-x64' and 'linux-arm64'"
    echo "${_indent}Default is empty and runtime is detected automatically."
    echo "${_indent}See also: https://docs.microsoft.com/en-us/dotnet/core/rid-catalog"
    echo
    echo "${_indent}-${_APPVERSION_ARG}, --${_APPVERSION_ARG_NAME} value"
    echo "${_indent}Specifies application version. Overrides APP_VERSION in conf file."
    echo
    echo "${_indent}-${_PROPERTY_ARG}, --${_PROPERTY_ARG_NAME} value"
    echo "${_indent}Specifies a property to be supplied to dotnet publish command. This option may appear"
    echo "${_indent}multiple times in the command. Do not use for application version. Do not include ';' character."
    echo "${_indent}Example: ${_SCRIPT_NAME} -${_PROPERTY_ARG} DefineConstants=TRACE -${_PROPERTY_ARG} Configuration=Mac"
    echo
    echo "${_indent}-${_ARCH_ARG}, --${_ARCH_ARG_NAME} value"
    echo "${_indent}Target architecture, i.e. as 'x86_64' or 'aarch64'. Note this is not normally necessary"
    echo "${_indent}as, in most cases, both AppImage and Flatpak builders can detect the arch automatically."
    echo "${_indent}However, in the event of a problem with this, the value may be specified explicitly."
    echo
    echo "${_indent}-${_OUTPUT_ARG}, --${_OUTPUT_ARG_NAME} value"
    echo "${_indent}Package output filename (excluding directory part). By default, the output name is derived"
    echo "${_indent}from the application name and architecture. However, it may be overidden with this option."
    echo
    echo "${_indent}-${_VERBOSE_ARG}, --${_VERBOSE_ARG_NAME}"
    echo "${_indent}Flag which indicates verbose output."
    echo
    echo "${_indent}-${_RUNAPP_ARG}, --${_RUNAPP_ARG_NAME}"
    echo "${_indent}Flag which performs a test run of the application after successful build."
    echo
    echo "${_indent}-${_SKIPYES_ARG}, --${_SKIPYES_ARG_NAME}"
    echo "${_indent}Flag which skips confirmation prompts (assumes yes)."
    echo

    echo "Example:"
    echo "${_indent}${_SCRIPT_NAME} -${_SKIPYES_ARG} -${_RID_ARG} linux-arm64"
    echo

    exit $_exit_help
fi


###############################
# SOURCE & WORKING
###############################

if [ ! -f "${_conf_arg_value}" ]; then

    if [ -f "publish-appimage.conf" ]; then
        ## Fallback to legacy name
        _conf_arg_value="publish-appimage.conf"
    else
        echo "File not found: ${_conf_arg_value}"
        echo
        exit 1
    fi
fi

# Export these now as may be
# useful in an advanced config file
export DOTNET_RID="${_rid_arg_value}"
export PKG_KIND="${_kind_arg_value}"
export ISO_DATE=`date +"%Y-%m-%d"`

# Export contents to any post publish command
set -a

# Source local to PWD
source "${_conf_arg_value}"
set +a

# Then change PWD to conf file
cd "$(dirname "${_conf_arg_value}")"


###############################
# SANITY
###############################

if (( ${CONF_IMPL_VERSION} < ${_SCRIPT_IMPL_MIN} )) || (( ${CONF_IMPL_VERSION} > ${_SCRIPT_IMPL_MAX} )); then
    echo "Configuration format version ${_SCRIPT_IMPL_VERSION} not compatible"
    echo "Older conf file but newer ${_SCRIPT_NAME} implementation?"
    echo "Update from: ${_SCRIPT_WEBSITE}"
    echo
    exit 1
fi

# Backward compat with Publish-AppImage
if [ "${APP_METADATA}" == "" ]; then
    export APP_METADATA="${APP_XML_SRC}"
fi

if [ "${APPIMAGETOOL_ARGS}" == "" ]; then
    export APPIMAGETOOL_ARGS="${PKG_APPIMAGE_ARGS}"
fi

# Mandatories
assert_mandatory "APP_MAIN" "${APP_MAIN}"
assert_mandatory "APP_ID" "${APP_ID}"
assert_mandatory "APP_ICON_SRC" "${APP_ICON_SRC}"
assert_mandatory "DE_NAME" "${DE_NAME}"
assert_mandatory "DE_CATEGORIES" "${DE_CATEGORIES}"
assert_mandatory "PKG_OUTPUT_DIR" "${PKG_OUTPUT_DIR}"

assert_flag "DE_TERMINAL_FLAG" "${DE_TERMINAL_FLAG}"
assert_flag "PKG_VERSION_FLAG" "${PKG_VERSION_FLAG}"

assert_opt_file "APP_ICON_SRC" "${APP_ICON_SRC}"
assert_opt_file "APP_METADATA" "${APP_METADATA}"

if [ "${_kind_arg_value}" == "${_APPIMAGE_KIND}" ]; then
    assert_mandatory "APPIMAGETOOL_COMMAND" "${APPIMAGETOOL_COMMAND}"
fi

if [ "${_kind_arg_value}" == "${_FLATPAK_KIND}" ]; then
    assert_mandatory "FLATPAK_PLATFORM_RUNTIME" "${FLATPAK_PLATFORM_RUNTIME}"
    assert_mandatory "FLATPAK_PLATFORM_VERSION" "${FLATPAK_PLATFORM_VERSION}"
    assert_mandatory "FLATPAK_PLATFORM_SDK" "${FLATPAK_PLATFORM_SDK}"
fi


if [ "${DOTNET_PROJECT_PATH}" == "${_DOTNET_NONE}" ] && [ "${POST_PUBLISH}" == "" ]; then
    echo "No publish or build operation defined (nothing will be built)"
    echo "See DOTNET_PROJECT_PATH and POST_PUBLISH in: ${_conf_arg_value}"
    echo
    exit 1
fi

if [ "${DOTNET_PROJECT_PATH}" != "" ] && [ "${DOTNET_PROJECT_PATH}" != "${_DOTNET_NONE}" ] &&
    [ ! -f "${DOTNET_PROJECT_PATH}" ] && [ ! -d "${DOTNET_PROJECT_PATH}" ]; then
    echo "DOTNET_PROJECT_PATH path not found: ${DOTNET_PROJECT_PATH}"
    echo
    exit 1
fi

if [ "${_kind_arg_value}" != "${_APPIMAGE_KIND}" ] &&
    [ "${_kind_arg_value}" != "${_FLATPAK_KIND}" ] &&
    [ "${_kind_arg_value}" != "${_ZIP_KIND}" ]; then
    echo "Invalid argument value: ${_kind_arg_value}"
    echo "Use one of: ${_APPIMAGE_KIND}, ${_FLATPAK_KIND} or ${_ZIP_KIND}"
    echo
    exit 1
fi


# Detect if publish for windows
_exec_ext=""
declare -l _tw="${_rid_arg_value}"

if [[ "${_tw}" == "win"* ]]; then

    # May use this in future
    _exec_ext=".exe"

    if [ "${_kind_arg_value}" == "${_APPIMAGE_KIND}" ] || [ "${_kind_arg_value}" == "${_FLATPAK_KIND}" ]; then
        echo "Invalid AppImage or Flatpak payload"
        echo "Looks like you're trying to package a windows binary as a Linux package?"
        echo "Use --${_KIND_ARG_NAME} ${_ZIP_KIND} instead."
        echo
        exit 1
    fi
fi


###############################
# VARIABLES
###############################

if [ "${_arch_arg_value}" != "" ]; then

    # Explicit
    _target_arch="${_arch_arg_value}"

    # Set ARCH if given explicitly - variable is used by AppImage.
    # We will also supply to flatpak builder.
    # https://discourse.appimage.org/t/how-to-package-for-aarch64/2088/4
    export ARCH="${_arch_arg_value}"

elif [ "${_rid_arg_value}" == "linux-x64" ]; then
    # Map common
    _target_arch="x86_64"
elif [ "${_rid_arg_value}" == "linux-arm64" ]; then
    # Map common
    _target_arch="aarch64"
elif [ "${_rid_arg_value}" == "" ]; then
    _target_arch="${_HOST_ARCH}"
else
    # Otherwise use RID itself for the filename
    _target_arch="${_rid_arg_value}"
fi

if [ "${_appversion_arg_value}" != "" ]; then
    # Override
    export APP_VERSION="${_appversion_arg_value}"
fi

# For AppImage tool and backward compatibility
export VERSION="${APP_VERSION}"

if [ "${TEMP_BUILD_DIR}" == "" ]; then
    export TEMP_BUILD_DIR="${PKG_OUTPUT_DIR}/temp"
fi

if [ "${FLATPAK_LOCAL_REPO}" == "" ]; then
    export FLATPAK_LOCAL_REPO="${TEMP_BUILD_DIR}/flatpak-repo"
fi

# APPDIR LOCATIONS
export APPDIR_ROOT="${TEMP_BUILD_DIR}/AppDir"

if [ "${_kind_arg_value}" == "${_ZIP_KIND}" ]; then
    # Simple zip - all same
    export APPDIR_USR="${APPDIR_ROOT}"
    export APPDIR_BIN="${APPDIR_ROOT}"
    export APPDIR_SHARE="${APPDIR_ROOT}"
else
    # AppImage or flatpak
    export APPDIR_USR="${APPDIR_ROOT}/usr"
    export APPDIR_BIN="${APPDIR_ROOT}/usr/bin"
    export APPDIR_SHARE="${APPDIR_ROOT}/usr/share"
fi

export APPRUN_TARGET="${APPDIR_BIN}/${APP_MAIN}${_exec_ext}"

# ICON
if [ "${APP_ICON_SRC}" != "" ]; then

    # Extract extension
    _icon_ext="${APP_ICON_SRC##*.}"

    if [ "${_icon_ext}" != "" ]; then
        _icon_ext=".${_icon_ext}"
    fi

    # No directory prefix
    _icon_fname="${APP_ID}${_icon_ext}"
fi


# DOTNET PUBLISH
if [ "${DOTNET_PROJECT_PATH}" != "${_DOTNET_NONE}" ]; then

    _publish_cmd="dotnet publish"

    if [ "${DOTNET_PROJECT_PATH}" != "" ] && [ "${DOTNET_PROJECT_PATH}" != "." ]; then
        _publish_cmd="${_publish_cmd} \"${DOTNET_PROJECT_PATH}\""
    fi

    if [ "${_rid_arg_value}" != "" ]; then
        _publish_cmd="${_publish_cmd} -r ${_rid_arg_value}"
    fi

    if [ "${APP_VERSION}" != "" ]; then
        _publish_cmd="${_publish_cmd} -p:Version=${APP_VERSION}"
    fi

    if [ "${_property_arg_value}" != "" ]; then
        _publish_cmd="${_publish_cmd}${_property_arg_value}"
    fi

    if [ "${DOTNET_PUBLISH_ARGS}" != "" ]; then
        _publish_cmd="${_publish_cmd} ${DOTNET_PUBLISH_ARGS}"
    fi

    _publish_cmd="${_publish_cmd} -o \"${APPDIR_BIN}\""

fi


# PACKAGE OUTPUT
if [ "${_output_arg_value}" != "" ]; then
    _package_out="${PKG_OUTPUT_DIR}/${_output_arg_value}"
fi

if [ "$PKG_VERSION_FLAG" == "true" ] && [ "${APP_VERSION}" != "" ]; then
    _version_out="-${APP_VERSION}"
fi

if [ "${_kind_arg_value}" == "${_ZIP_KIND}" ]; then

    # Simple zip
    if [ "${_package_out}" == "" ]; then
        _package_out="${PKG_OUTPUT_DIR}/${APP_MAIN}${_version_out}-${_target_arch}.zip"
    fi

    if [[ "${_package_out}" == /* ]]; then
        _file="${_package_out}"
    else
        _file="${PWD}/${_package_out}"
    fi

    _package_cmd="(cd \"${APPDIR_ROOT}\" && zip -r \"${_file}\" ./)"

    if [ ${_runapp_arg_value} == true ]; then
        _packrun_cmd="${APPRUN_TARGET}"
    fi

elif [ "${_kind_arg_value}" == "${_FLATPAK_KIND}" ]; then

    # Flatpak
    if [ "${_package_out}" == "" ]; then
        _package_out="${PKG_OUTPUT_DIR}/${APP_MAIN}${_version_out}-${_target_arch}.flatpak"
    fi

    _flatpak_temp_dir="${TEMP_BUILD_DIR}/flatpak-build"
    _flatpak_state="${TEMP_BUILD_DIR}/flatpak-state"
    _flatpak_manifest_path="${TEMP_BUILD_DIR}/${APP_ID}.yml"

    _package_cmd="flatpak-builder"

    # Args
    if [ "${FLATPAK_BUILDER_ARGS}" != "" ]; then
        _package_cmd="${_package_cmd} ${FLATPAK_BUILDER_ARGS}"
    fi

    if [ "${ARCH}" != "" ]; then
        # Has been set explicitly
        _package_cmd="${_package_cmd} --arch ${ARCH}"
    fi

    _package_cmd="${_package_cmd} --repo=\"${FLATPAK_LOCAL_REPO}\" --force-clean \"${_flatpak_temp_dir}\" --state-dir \"${_flatpak_state}\" \"${_flatpak_manifest_path}\""
    _package_cmd="(${_package_cmd} && flatpak build-bundle \"${FLATPAK_LOCAL_REPO}\" \"${_package_out}\" ${APP_ID})"

    if [ ${_runapp_arg_value} == true ]; then
        _packrun_cmd="flatpak-builder --run \"${_flatpak_temp_dir}\" \"${_flatpak_manifest_path}\" ${APP_MAIN} --state-dir \"${_flatpak_state}\""
    fi


    # NB. Source relative to manifest file
    _temp="app-id: ${APP_ID}\n"
    _temp="${_temp}runtime: ${FLATPAK_PLATFORM_RUNTIME}\n"
    _temp="${_temp}runtime-version: '${FLATPAK_PLATFORM_VERSION}'\n"
    _temp="${_temp}sdk: ${FLATPAK_PLATFORM_SDK}\n"
    _temp="${_temp}command: ${APP_MAIN}\n"
    _temp="${_temp}modules:\n"
    _temp="${_temp}  - name: ${APP_MAIN}\n"
    _temp="${_temp}    buildsystem: simple\n"
    _temp="${_temp}    build-commands:\n"
    _temp="${_temp}      - mkdir -p /app/bin\n"
    _temp="${_temp}      - cp bin/* /app/bin/\n"
    _temp="${_temp}      - install -Dm644 ${APP_ID}.desktop /app/share/applications/${APP_ID}.desktop\n"
    _temp="${_temp}      - install -Dm644 ${_icon_fname} /app/share/icons/hicolor/scalable/apps/${_icon_fname}\n"
    _temp="${_temp}      - install -Dm644 ${APP_ID}.appdata.xml /app/share/metainfo/${APP_ID}.appdata.xml\n"
    _temp="${_temp}    sources:\n"
    _temp="${_temp}      - type: dir\n"
    _temp="${_temp}        path: AppDir/usr/\n"
    _temp="${_temp}      - type: file\n"
    _temp="${_temp}        path: AppDir/${APP_ID}.desktop\n"
    _temp="${_temp}      - type: file\n"
    _temp="${_temp}        path: AppDir/${_icon_fname}\n"
    _temp="${_temp}      - type: file\n"
    _temp="${_temp}        path: AppDir/usr/share/metainfo/${APP_ID}.appdata.xml\n"

    if [ "${FLATPAK_FINISH_ARGS}" != "" ]; then

        _temp="${_temp}finish-args:\n"

        # Format
        _lf="\n"
        _finish_args="${FLATPAK_FINISH_ARGS//|/${_lf}}"
        _finish_args="${_finish_args//--/  - --}"
        _temp="${_temp}${_finish_args}\n"
    fi

    _flatpak_manifest="${_temp}"
    _desktop_exec="${APP_MAIN}${exec_ext}"

else

    # AppImageTool
    if [ "${_package_out}" == "" ]; then
        _package_out="${PKG_OUTPUT_DIR}/${APP_MAIN}${_version_out}-${_target_arch}.AppImage"
    fi

    _package_cmd="${APPIMAGETOOL_COMMAND}"

    # Args
    if [ "${APPIMAGETOOL_ARGS}" != "" ]; then
        _package_cmd="${_package_cmd} ${APPIMAGETOOL_ARGS}"
    fi

    _package_cmd="${_package_cmd} \"${APPDIR_ROOT}\" \"${_package_out}\""

    if [ ${_runapp_arg_value} == true ]; then
        _packrun_cmd="${_package_out}"
    fi

    _desktop_exec="AppRun"
fi


###############################
# DESKTOP ENTRY & APPDATA
###############################

if [ "${_kind_arg_value}" == "${_APPIMAGE_KIND}" ] || [ "${_kind_arg_value}" == "${_FLATPAK_KIND}" ]; then

    _desktop="[Desktop Entry]\n"
    _desktop="${_desktop}Type=Application\n"
    _desktop="${_desktop}Name=${DE_NAME}\n"
    _desktop="${_desktop}Exec=${_desktop_exec}\n"
    _desktop="${_desktop}Terminal=${DE_TERMINAL_FLAG}\n"
    _desktop="${_desktop}Categories=${DE_CATEGORIES}\n"

    # Follow app-id
    _desktop="${_desktop}Icon=${APP_ID}"

    if [ "${DE_COMMENT}" != "" ]; then
        _desktop="${_desktop}\nComment=${DE_COMMENT}"
    fi

    if [ "${DE_KEYWORDS}" != "" ]; then
        _desktop="${_desktop}\nKeywords=${DE_KEYWORDS}"
    fi

    if [ "${DE_EXTEND}" != "" ]; then
        _lf="\n"
        _desktop="${_desktop}\n${DE_EXTEND//|/${_lf}}"
    fi

    # Load appdata.xml
    if [ "${APP_METADATA}" != "" ]; then

        if command -v envsubst &> /dev/null; then
            _appxml=$(envsubst <"${APP_METADATA}")
        else
            _appxml=$(<"${APP_METADATA}")
            echo "WARNING: Variable substitution not available for: ${APP_METADATA}"
            echo
        fi

    fi

fi


###############################
# DISPLAY & CONFIRM
###############################

echo "${_SCRIPT_TITLE}, ${_SCRIPT_VERSION}"
echo "${_SCRIPT_COPYRIGHT}"
echo

echo "==================="
echo "APPLICATION"
echo "==================="
echo "APP_MAIN: ${APP_MAIN}"
echo "APP_ID: ${APP_ID}"
echo "APP_VERSION: ${APP_VERSION}"

echo
echo "==================="
echo "PACKAGE"
echo "==================="
echo "PACKAGE KIND: ${_kind_arg_value}"

if [ "${DOTNET_PROJECT_PATH}" != "${_DOTNET_NONE}" ]; then
    echo "DOTNET RID: ${_rid_arg_value}"
else
    echo "DOTNET RID: [default]"
fi

echo "ARCH: ${_target_arch}"
echo "PACKAGE OUT: ${_package_out}"

if [ "${_desktop}" != "" ]; then
    echo
    echo "==================="
    echo "DESKTOP"
    echo "==================="
    echo -e "${_desktop}"
fi

if [ "${_flatpak_manifest}" != "" ]; then
    echo
    echo "==================="
    echo "FLATPAK MANIFEST"
    echo "==================="
    echo -e "${_flatpak_manifest}"
fi

if [ ${_verbose_arg_value} == true ]; then

    if [ "${_appxml}" != "" ]; then
        echo
        echo "==================="
        echo "APPDATA.XML"
        echo "==================="
        echo -e "${_appxml}"
    fi
fi

echo
echo "==================="
echo "BUILD"
echo "==================="
echo "APPDIR_ROOT: ${APPDIR_ROOT}"

if [ "${_kind_arg_value}" == "${_FLATPAK_KIND}" ]; then
    echo "FLATPAK_LOCAL_REPO: ${FLATPAK_LOCAL_REPO}"
fi

if [ "${_publish_cmd}" != "" ]; then
    echo
    echo "DOTNET PUBLISH:"
    echo "${_publish_cmd}"
else
    echo
    echo "DOTNET PUBLISH: ${_DOTNET_NONE}"
fi

if [ "${POST_PUBLISH}" != "" ]; then
    echo
    echo "POST PUBLISH:"
    echo "${POST_PUBLISH}"
else
    echo
    echo "POST PUBLISH: [none]"
fi

echo
echo "BUILD COMMAND:"
echo "${_package_cmd}"

if [ "${_packrun_cmd}" != "" ]; then
    echo
    echo "TEST RUN:"
    echo "${_packrun_cmd}"
fi

echo

# Prompt
if [ $_skipyes_arg_value == false ]; then

    read -p "Build now [N/y]? " prompt

    if [ "${prompt}" != "y" ] && [ "${prompt}" != "Y" ]; then
        echo
        exit 1
    fi

    # Continue
    echo
fi


###############################
# PUBLISH & BUILD
###############################

# Clean and ensure directoy exists
ensure_directory "${PKG_OUTPUT_DIR}"
remove_path "${APPDIR_ROOT}"
remove_path "${_package_out}"

# Create AppDir structure
ensure_directory "${TEMP_BUILD_DIR}"
ensure_directory "${APPDIR_BIN}"

if [ "${_kind_arg_value}" != "${_ZIP_KIND}" ]; then
    # We also create usr/share/icons, as some packages require this.
    # See: https://github.com/kuiperzone/Publish-AppImage/issues/7
    ensure_directory "${APPDIR_SHARE}/icons"
fi

echo

# Publish dotnet
if [ "${_publish_cmd}" != "" ]; then
    exec_or_die "${_publish_cmd}"
    echo
fi

# Post-publish
if [ "${POST_PUBLISH}" != "" ]; then

    exec_or_die "${POST_PUBLISH}"
    echo

fi

# Application file must exist!
if [ ! -f "${APPRUN_TARGET}" ]; then
    echo "Expected application file not found: ${APPRUN_TARGET}"
    echo
    exit 1
fi

if [ "${_kind_arg_value}" == "${_APPIMAGE_KIND}" ] || [ "${_kind_arg_value}" == "${_FLATPAK_KIND}" ]; then

    echo

    # Create desktop
    if [ "${_desktop}" != "" ]; then
        _file="${APPDIR_ROOT}/${APP_ID}.desktop"
        echo "Creating: ${_file}"
        echo -e "${_desktop}" > "${_file}"
        assert_result
    fi

    # Create manifest if any
    if [ "${_flatpak_manifest}" != "" ]; then
        echo "Creating: ${_flatpak_manifest_path}"
        echo -e "${_flatpak_manifest}" > "${_flatpak_manifest_path}"
        assert_result
    fi

    # Create appdata.xml
    if [ "${_appxml}" != "" ]; then
        _dir="${APPDIR_SHARE}/metainfo"
        _file="${_dir}/${APP_ID}.appdata.xml"
        echo "Creating: ${_file}"
        ensure_directory "${_dir}"
        echo -e "${_appxml}" > "${_file}"
        assert_result

        if [ "${_desktop}" != "" ]; then
            # Copy of desktop under "applications"
            # Needed for launchable in appinfo.xml (if used)
            # See https://github.com/AppImage/AppImageKit/issues/603
            _dir="${APPDIR_SHARE}/applications"
            _file="${_dir}/${APP_ID}.desktop"
            echo "Creating: ${_file}"
            ensure_directory "${_dir}"
            echo -e "${_desktop}" > "${_file}"
            assert_result
        fi
    fi

    # Copy icon
    if [ "${_icon_fname}" != "" ]; then

        _file="${APPDIR_ROOT}/${_icon_fname}"
        echo "Creating: ${_file}"
        cp "${APP_ICON_SRC}" "${_file}"
        assert_result
    fi

    # AppRun (AppImage only)
    _file="${APPDIR_ROOT}/AppRun"

    if [ ! -f "${_file}" ]; then

        echo "Creating: ${_file}"
        ln -s "usr/bin/${APP_MAIN}${_exec_ext}" "${_file}"
        assert_result
    fi
fi

# Build package
echo
exec_or_die "${_package_cmd}"
echo

echo "OUTPUT OK: ${_package_out}"
echo

if [ "${_packrun_cmd}" != "" ]; then
    echo "RUNNING ..."
    exec_or_die "${_packrun_cmd}"
    echo
fi

exit 0
